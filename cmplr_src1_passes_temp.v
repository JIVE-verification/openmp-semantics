From Coq Require Import String List ZArith.
From compcert Require Import Coqlib Integers Floats Values AST Ctypes Cop Csyntax Csyntaxdefs.
Import Csyntaxdefs.CsyntaxNotations.
Local Open Scope Z_scope.
Local Open Scope string_scope.
Local Open Scope csyntax_scope.

Module Info.
  Definition version := "3.14".
  Definition build_number := "".
  Definition build_tag := "".
  Definition build_branch := "".
  Definition arch := "aarch64".
  Definition model := "default".
  Definition abi := "apple".
  Definition bitsize := 64.
  Definition big_endian := false.
  Definition source_file := "cmplr_src1.c".
End Info.
Compute ((Zpos $"df")+(Zpos $"j")).
Definition ___stringlit_1 : ident := $"__stringlit_1".
Definition _i : ident := $"i".
Definition _j : ident := $"j".
Definition _k : ident := $"k".
Definition _l : ident := $"l".
Definition _main : ident := $"main".
Definition _printf : ident := $"printf".

Definition v___stringlit_1 := {|
  gvar_info := (tarray tschar 24);
  gvar_init := (Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 61) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 37) :: Init_int8 (Int.repr 100) ::
                Init_int8 (Int.repr 44) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 106) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 61) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 37) :: Init_int8 (Int.repr 100) ::
                Init_int8 (Int.repr 44) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 107) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 61) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 37) :: Init_int8 (Int.repr 100) ::
                Init_int8 (Int.repr 10) :: Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition f_main := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := ((_i, tint) :: (_j, tint) :: (_k, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Sdo (Eassign (Evar _i tint) (Eval (Vint (Int.repr 0)) tint) tint))
    (Ssequence
      (Sdo (Eassign (Evar _j tint) (Eval (Vint (Int.repr 0)) tint) tint))
      (Ssequence
        (Sdo (Eassign (Evar _k tint) (Eval (Vint (Int.repr 0)) tint) tint))
        (Ssequence
          (Ssequence
            (Sdo (Epostincr Incr (Evar _i tint) tint))
            (Ssequence
              (Sdo (Eassign (Evar _j tint) (Eval (Vint (Int.repr 1)) tint)
                     tint))
              (Sdo (Eassign (Evar _k tint) (Eval (Vint (Int.repr 1)) tint)
                     tint))))
          (Sdo (Ecall
                 (Evalof
                   (Evar _printf (Tfunction (Tcons (tptr tschar) Tnil) tint
                                   {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|}))
                   (Tfunction (Tcons (tptr tschar) Tnil) tint
                     {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|}))
                 (Econs
                   (Evalof (Evar ___stringlit_1 (tarray tschar 24))
                     (tarray tschar 24))
                   (Econs (Evalof (Evar _i tint) tint)
                     (Econs (Evalof (Evar _j tint) tint)
                       (Econs (Evalof (Evar _k tint) tint) Enil)))) tint))))))
  (Sreturn (Some (Eval (Vint (Int.repr 0)) tint))))
|}.

Definition composites : list composite_definition :=
nil.

Definition global_definitions : list (ident * globdef fundef type) :=
(
 (_printf,
   Gfun(External (EF_external "printf"
                   (mksignature (AST.Tlong :: nil) AST.Tint
                     {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tint
     {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|})) ::
 (_main, Gfun(Internal f_main)) :: nil).

Definition public_idents : list ident :=
(_main :: _printf :: 
 nil).

Definition prog : Csyntax.program := 
  mkprogram composites global_definitions public_idents _main Logic.I.


(* above are generated by `clightgen -Csyntax`. Developments start here. *)
From stdpp Require Import base list.
From compcert Require Import Clight SimplExpr Ctypes.
Local Open Scope Z_scope.

(* step 1: apply the SimplExpr pass but not the SimplLocal pass, so everything is
still on heap *)
Definition prog_clight' :=
  transl_program prog.

(* print clight ast *)
Example print_f_main_clight : True.
  let p := eval cbn in prog_clight' in
  match p with
  | Errors.OK ?p => idtac p end.
  Abort.
  
Definition f_main_clight :=
  {|
    fn_return := tint;
    fn_callconv := cc_default;
    fn_params := nil;
    fn_vars := (_i, tint) :: (_j, tint) :: (_k, tint) :: nil;
    fn_temps := nil;
    fn_body :=
      Ssequence
        (Ssequence
           (Ssequence Sskip
              (Sassign (Evar _i tint)
                 (Econst_int (Int.repr 0) tint)))
           (Ssequence
              (Ssequence Sskip
                 (Sassign (Evar _j tint)
                    (Econst_int (Int.repr 0) tint)))
              (Ssequence
                 (Ssequence Sskip
                    (Sassign (Evar _k tint)
                       (Econst_int (Int.repr 0) tint)))
                 (Ssequence
                    (Ssequence
                       (Ssequence Sskip
                          (Sassign (Evar _i tint)
                             (Ebinop Oadd 
                                (Evar _i tint)
                                (Econst_int Int.one type_int32s)
                                (Tint I32 Signed noattr))))
                       (Ssequence
                          (Ssequence Sskip
                             (Sassign (Evar _j tint)
                                (Econst_int (Int.repr 1) tint)))
                          (Ssequence Sskip
                             (Sassign (Evar _k tint)
                                (Econst_int (Int.repr 1) tint)))))
                    (Ssequence Sskip
                       (Scall None
                          (Evar _printf
                             (Tfunction 
                                (Tcons (tptr tschar) Tnil) tint
                                {|
                                  cc_vararg := Some 1;
                                  cc_unproto := false;
                                  cc_structret := false
                                |}))
                          (Evar ___stringlit_1 (tarray tschar 24)
                           :: Evar _i tint
                              :: Evar _j tint
                                 :: Evar _k tint :: nil)))))))
        (Ssequence Sskip
           (Sreturn (Some (Econst_int (Int.repr 0) tint))))
  |}.
Check f_main.
Check f_main_clight.
Locate function.
Search compcert.cfrontend.Csyntax.function.

Definition prog_clight :=
  {|
  prog_defs :=
	(_printf,
     Gfun
       (External
          (EF_external "printf"
             {|
               sig_args := AST.Tlong :: nil;
               sig_res := AST.Tint;
               sig_cc :=
                 {|
                   cc_vararg := Some 1;
                   cc_unproto := false;
                   cc_structret := false
                 |}
             |}) (Tcons (tptr tschar) Tnil) tint
          {|
            cc_vararg := Some 1; cc_unproto := false; cc_structret := false
          |}))
    :: (_main, Gfun (Internal f_main_clight))
              :: nil;
  prog_public := public_idents;
  prog_main := _main;
  prog_types := composites;
  prog_comp_env := Maps.PTree.empty composite;
  prog_comp_env_eq := eq_refl
|}.

Lemma f_main_clight_eq :
  Errors.OK prog_clight = prog_clight'.
Proof. reflexivity. Qed.
Locate Econst_int.
Definition parallel_body : statement :=
  (Ssequence
    (Ssequence Sskip
      (Sassign (Evar _i tint)
          (Ebinop Oadd 
            (Evar _i tint)
            (Econst_int Int.one type_int32s)
            (Tint I32 Signed noattr))))
    (Ssequence
      (Ssequence Sskip
          (Sassign (Evar _j tint)
            (Econst_int (Int.repr 1) tint)))
      (Ssequence Sskip
          (Sassign (Evar _k tint)
            (Econst_int (Int.repr 1) tint))))).

(* step 2 : manually annotate f_main_clight with pragma steps *)
Definition f_main_omp :=
  {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := ((_i, tint) :: (_j, tint) :: (_k, tint) :: (_l, tint) :: nil);
  fn_temps := nil;
  fn_body :=
(Ssequence
  (Ssequence
    (Sset _i (Econst_int (Int.repr 0) tint))
    (Ssequence
      (Sset _j (Econst_int (Int.repr 0) tint))
      (Ssequence
        (Sset _k (Econst_int (Int.repr 0) tint))
        (Ssequence
          (Ssequence
            (Sset _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))
            (Ssequence
              (Sset _j (Econst_int (Int.repr 1) tint))
              (Ssequence
                (Sset _k (Econst_int (Int.repr 1) tint))
                (Sset _l (Econst_int (Int.repr 0) tint)))))
          (Ssequence (Spragma 0 (OMPParallel 2 (PrivClause (_j::nil)) ((RedClause RedIdPlus (_k::nil))::nil))
                  parallel_body)
          (Scall None
            (Evar _printf (Tfunction (Tcons (tptr tschar) Tnil) tint
                            {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|}))
            ((Evar ___stringlit_1 (tarray tschar 24)) ::
             (Etempvar _i tint) :: (Etempvar _j tint) ::
             (Etempvar _k tint) :: nil)))))))
  (Sreturn (Some (Econst_int (Int.repr 0) tint))))
|}.

  Fixpoint extracting_spragma (s: statement): option statement:=
  match s with
  | Ssequence a b => match extracting_spragma a with
                    | Some s => Some s
                    | None => extracting_spragma b
                    end
  | Sifthenelse a b c => match extracting_spragma b with
                    | Some s => Some s
                    | None => extracting_spragma c
                    end   
  | Sloop a b => match extracting_spragma a with
                    | Some s => Some s
                    | None => extracting_spragma b
                    end   
  | Slabel a b => extracting_spragma b
  | Spragma a b c => Some s   
  |_ => None            
  end.
Type extracting_spragma.
  Definition extracted_pragma_parallel_material (f: function): option function:=
  (*TODO: revise argments to mkfunction*)
  match extracting_spragma (fn_body f) with 
  | Some s => Some (mkfunction (tptr tvoid) (fn_callconv f) (fn_params f) (fn_vars f) (fn_temps f) s)
  | None => None
  end.
  Type extracted_pragma_parallel_material.
  Compute fn_params f_main_omp.
  Compute fn_temps f_main_omp.
  Compute extracted_pragma_parallel_material f_main_omp.
  Definition adding_ident (identifier: (ident * type)) (existing_list: list (ident * type)):=
  identifier::existing_list.
  Type _i.
  Type type.
(* Compute adding_ident (_i, Tint) (fn_temps f_main_omp). *)
  Compute extracted_pragma_parallel_material (f_main_omp).
  Search "routine".
(*design of function: maybe recurse until encountering SPragma with parallel?*)
(* step 3: find all variables used in a parallel pragma, figure out which ones are private,
   which ones are shared and whihch ones are reduction variables.
   Nested parallel regions need recursive calls *)

Inductive pragma_info : Type :=
(* shared vars, vars in the private cluse and vars in the reduction clause *)
  | ParallelInfo : list (ident * type) -> list (ident * type) -> list (ident * type) -> pragma_info.

Definition empty_pragma_info : pragma_info :=
  ParallelInfo nil nil nil.

(* private variables are those specified in the private clause plus those in the reduction  *)
Definition parallel_info_spec (par_info: pragma_info) vars: Prop :=
  match par_info with
  | ParallelInfo ss ps rs => 
      ss ⊆ vars ∧ ps ⊆ vars ∧ rs ⊆ vars ∧
      list_disjoint ss ps ∧ list_disjoint ss rs ∧ list_disjoint ps rs
  end.
 
(* lifts analysis info to an AST tagged with info *)
Inductive statementT : Type :=
  | SskipT : statementT                   (**r do nothing *)
  | SassignT : expr -> expr -> statementT (**r assignment [lvalue = rvalue] *)
  | SsetT : ident -> expr -> statementT   (**r assignment [tempvar = rvalue] *)
  | ScallT: option ident -> expr -> list expr -> statementT (**r function call *)
  | SbuiltinT: option ident -> external_function -> typelist -> list expr -> statementT (**r builtin invocation *)
  | SsequenceT : statementT -> statementT -> statementT  (**r sequence *)
  | SifthenelseT : expr  -> statementT -> statementT -> statementT (**r conditional *)
  | SloopT: statementT -> statementT -> statementT (**r infinite loop *)
  | SbreakT : statementT                      (**r [break] statementT *)
  | ScontinueT : statementT                   (**r [continue] statementT *)
  | SreturnT : option expr -> statementT      (**r [return] statementT *)
  | SswitchT : expr -> labeled_statementsT -> statementT  (**r [switch] statementT *)
  | SlabelT : label -> statementT -> statementT
  | SgotoT : label -> statementT
  (* each Spragma in the program is indexed by a uniquely natural number *)
  | SpragmaT : pragma_info -> nat -> pragma_label -> statementT -> statementT

with labeled_statementsT : Type :=            (**r cases of a [switch] *)
  | LSnilT: labeled_statementsT
  | LSconsT: option Z -> statementT -> labeled_statementsT -> labeled_statementsT.
                      (**r [None] is [default], [Some x] is [case x] *)
              
Fixpoint erase_info (sT: statementT) : statement :=
  match sT with
  | SskipT => Sskip
  | SassignT l r => Sassign l r
  | SsetT id e => Sset id e
  | ScallT id e args => Scall id e args
  | SbuiltinT id ef tl args => Sbuiltin id ef tl args
  | SsequenceT s1 s2 => Ssequence (erase_info s1) (erase_info s2)
  | SifthenelseT e s1 s2 => Sifthenelse e (erase_info s1) (erase_info s2)
  | SloopT s1 s2 => Sloop (erase_info s1) (erase_info s2)
  | SbreakT => Sbreak
  | ScontinueT => Scontinue
  | SreturnT oe => Sreturn oe
  | SswitchT e ls => Sswitch e (erase_info_labeled_statements ls)
  | SlabelT l s => Slabel l (erase_info s)
  | SgotoT l => Sgoto l
  | SpragmaT _ n pl s => Spragma n pl (erase_info s)
  end
  with erase_info_labeled_statements (lsT: labeled_statementsT) : labeled_statements :=
  match lsT with
  | LSnilT => LSnil
  | LSconsT c s ls => LScons c (erase_info s) (erase_info_labeled_statements ls)
  end
  .

(* idea: instead of dealing with nested parallel regions, we only transform the deepestly
   nested parallel region (i.e. a parallel region that does not have a parallel region nested
   inside it). Then an ident in `Evar id _` in that region must be one of these:
   1. privatized variable, must be shared in the outer parallel region. 
   2. reduction variable, similar to 1
   3. local, declared in this parallel region
   4. otherwise, shared.  *)
Fixpoint stmt_to_stmtT (stmt: statement) : statementT :=
  match stmt with
  | Sskip => SskipT
  | Sassign l r => SassignT l r
  | Sset id e => SsetT id e
  | Scall id e args => ScallT id e args
  | Sbuiltin id ef tl args => SbuiltinT id ef tl args
  | Ssequence s1 s2 => SsequenceT (stmt_to_stmtT s1) (stmt_to_stmtT s2)
  | Sifthenelse e s1 s2 => SifthenelseT e (stmt_to_stmtT s1) (stmt_to_stmtT s2)
  | Sloop s1 s2 => SloopT (stmt_to_stmtT s1) (stmt_to_stmtT s2)
  | Sbreak => SbreakT
  | Scontinue => ScontinueT
  | Sreturn oe => SreturnT oe
  | Sswitch e ls => SswitchT e (labeled_statements_to_labeled_statementsT ls)
  | Slabel l s => SlabelT l (stmt_to_stmtT s)
  | Sgoto l => SgotoT l
  | Spragma n pl stmt' => SpragmaT empty_pragma_info n pl (stmt_to_stmtT stmt')
  end
with labeled_statements_to_labeled_statementsT (ls: labeled_statements) : labeled_statementsT :=
  match ls with
  | LSnil => LSnilT
  | LScons c s ls' => LSconsT c (stmt_to_stmtT s) (labeled_statements_to_labeled_statementsT ls')
  end.

  Record annotatedFunction  : Type := makeAnnotatedFunction {
  fn_return_annot: type;
  fn_callconv_annot: calling_convention;
  fn_params_annot: list (ident * type);
  fn_vars_annot: list (ident * type);
  fn_temps_annot: list (ident * type);
  fn_body_annot: statementT
}.

Definition parallel_body_T : statementT :=
  (SsequenceT
    (SsequenceT SskipT
      (SassignT (Evar _i tint)
          (Ebinop Oadd 
            (Evar _i tint)
            (Econst_int Int.one type_int32s)
            (Tint I32 Signed noattr))))
    (SsequenceT
      (SsequenceT SskipT
          (SassignT (Evar _j tint)
            (Econst_int (Int.repr 1) tint)))
      (SsequenceT SskipT
          (SassignT (Evar _k tint)
            (Econst_int (Int.repr 1) tint))))).

Definition full_pragma_info : pragma_info := ParallelInfo [(_i, tint)] [(_j, tint)] [(_k, tint)].
Definition f_main_omp_annot :=
  {|
    fn_return_annot := tint;
  fn_callconv_annot := cc_default;
  fn_params_annot := nil;
  fn_vars_annot := ((_i, tint) :: (_j, tint) :: (_k, tint) :: (_l, tint) :: nil);
  fn_temps_annot := nil;
  fn_body_annot :=
(SsequenceT
  (SsequenceT
    (SsetT _i (Econst_int (Int.repr 0) tint))
    (SsequenceT
      (SsetT _j (Econst_int (Int.repr 0) tint))
      (SsequenceT
        (SsetT _k (Econst_int (Int.repr 0) tint))
        (SsequenceT
          (SsequenceT
            (SsetT _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))
            (SsequenceT
              (SsetT _j (Econst_int (Int.repr 1) tint))
              (SsequenceT
                (SsetT _k (Econst_int (Int.repr 1) tint))
                (SsetT _l (Econst_int (Int.repr 0) tint)))))
          (SsequenceT (SpragmaT full_pragma_info 0 (OMPParallel 2 (PrivClause (_j::nil)) ((RedClause RedIdPlus (_k::nil))::nil))
                  parallel_body_T)     
          (ScallT None
            (Evar _printf (Tfunction (Tcons (tptr tschar) Tnil) tint
                            {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|}))
            ((Evar ___stringlit_1 (tarray tschar 24)) ::
             (Etempvar _i tint) :: (Etempvar _j tint) ::
             (Etempvar _k tint) :: nil)))))))
  (SreturnT (Some (Econst_int (Int.repr 0) tint))))
  |}.

Fixpoint extracting_spragma_T (s: statementT): option statementT:=
  match s with
  | SsequenceT a b => match extracting_spragma_T a with
                    | Some s => Some s
                    | None => extracting_spragma_T b
                    end
  | SifthenelseT a b c => match extracting_spragma_T b with
                    | Some s => Some s
                    | None => extracting_spragma_T c
                    end   
  | SloopT a b => match extracting_spragma_T a with
                    | Some s => Some s
                    | None => extracting_spragma_T b
                    end   
  | SlabelT a b => extracting_spragma_T b
  | SpragmaT a b c d => Some s   
  |_ => None            
  end.

Definition extracted_pragma_parallel_material_T (f: annotatedFunction): option annotatedFunction:=
  (*TODO: revise argments to mkfunction*)
  match extracting_spragma_T (fn_body_annot f) with 
  | Some s => Some (makeAnnotatedFunction (tptr tvoid) (fn_callconv_annot f) (fn_params_annot f) (fn_vars_annot f) (fn_temps_annot f) s)
  | None => None
  end.

  Compute extracted_pragma_parallel_material_T f_main_omp_annot.

(*TODO: add all cases and translate SpragmaT into something that's not a pragma*)
Fixpoint compiler_to_clight_function (s: statementT) : statement :=
 match s with
  | SsequenceT a b => Ssequence (compiler_to_clight_function a) (compiler_to_clight_function b)
  | SifthenelseT a b c => Sifthenelse a (compiler_to_clight_function b) (compiler_to_clight_function c)
  | SloopT a b => Sloop (compiler_to_clight_function a) (compiler_to_clight_function b)  
  | SlabelT a b => Slabel a (compiler_to_clight_function b)
  | SpragmaT a b c d => (compiler_to_clight_function d)
  |_ => Sskip            
  end.