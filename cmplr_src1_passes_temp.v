From Coq Require Import String List ZArith.
From compcert Require Import Coqlib Integers Floats Values AST Ctypes Cop Csyntax Csyntaxdefs.
Import Csyntaxdefs.CsyntaxNotations.
Local Open Scope Z_scope.
Local Open Scope string_scope.
Local Open Scope csyntax_scope.

Module Info.
  Definition version := "3.14".
  Definition build_number := "".
  Definition build_tag := "".
  Definition build_branch := "".
  Definition arch := "aarch64".
  Definition model := "default".
  Definition abi := "apple".
  Definition bitsize := 64.
  Definition big_endian := false.
  Definition source_file := "cmplr_src1.c".
End Info.
(* Compute ((Zpos $"df")+(Zpos $"j")). *)
Definition ___stringlit_1 : ident := $"__stringlit_1".
Definition _i : ident := $"i".
Definition _j : ident := $"j".
Definition _k : ident := $"k".
Definition _l : ident := $"l".
Definition _main : ident := $"main".
Definition _printf : ident := $"printf".
Definition _lock_1 : ident := $"lock_1".
Definition _lock_2 : ident := $"lock_2".
Definition _atom_int : ident := $"atom_int".
Definition ___par_routine1_data_1 : ident := $"__par_routine1_data_1".
Definition __par_routine1_data_ty : ident := $"_par_routine1_data_ty".
Definition ___par_routine1_data_2 : ident := $"__par_routine1_data_2".
Definition _t2 : ident := $"t2".
Definition _makelock : ident := $"makelock".
Definition _spawn : ident := $"spawn".
Definition __par_routine1 : ident := $"_par_routine1".
Definition _join_thread : ident := $"join_thread".
Definition _freelock : ident := $"freelock".

Definition v___stringlit_1 := {|
  gvar_info := (tarray tschar 24);
  gvar_init := (Init_int8 (Int.repr 105) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 61) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 37) :: Init_int8 (Int.repr 100) ::
                Init_int8 (Int.repr 44) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 106) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 61) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 37) :: Init_int8 (Int.repr 100) ::
                Init_int8 (Int.repr 44) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 107) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 61) :: Init_int8 (Int.repr 32) ::
                Init_int8 (Int.repr 37) :: Init_int8 (Int.repr 100) ::
                Init_int8 (Int.repr 10) :: Init_int8 (Int.repr 0) :: nil);
  gvar_readonly := true;
  gvar_volatile := false
|}.

Definition f_main := {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := ((_i, tint) :: (_j, tint) :: (_k, tint) :: nil);
  fn_body :=
(Ssequence
  (Ssequence
    (Sdo (Eassign (Evar _i tint) (Eval (Vint (Int.repr 0)) tint) tint))
    (Ssequence
      (Sdo (Eassign (Evar _j tint) (Eval (Vint (Int.repr 0)) tint) tint))
      (Ssequence
        (Sdo (Eassign (Evar _k tint) (Eval (Vint (Int.repr 0)) tint) tint))
        (Ssequence
          (Ssequence
            (Sdo (Epostincr Incr (Evar _i tint) tint))
            (Ssequence
              (Sdo (Eassign (Evar _j tint) (Eval (Vint (Int.repr 1)) tint)
                     tint))
              (Sdo (Eassign (Evar _k tint) (Eval (Vint (Int.repr 1)) tint)
                     tint))))
          (Sdo (Ecall
                 (Evalof
                   (Evar _printf (Tfunction (Tcons (tptr tschar) Tnil) tint
                                   {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|}))
                   (Tfunction (Tcons (tptr tschar) Tnil) tint
                     {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|}))
                 (Econs
                   (Evalof (Evar ___stringlit_1 (tarray tschar 24))
                     (tarray tschar 24))
                   (Econs (Evalof (Evar _i tint) tint)
                     (Econs (Evalof (Evar _j tint) tint)
                       (Econs (Evalof (Evar _k tint) tint) Enil)))) tint))))))
  (Sreturn (Some (Eval (Vint (Int.repr 0)) tint))))
|}.

Definition composites : list composite_definition :=
nil.

Definition global_definitions : list (ident * globdef fundef type) :=
(
 (_printf,
   Gfun(External (EF_external "printf"
                   (mksignature (AST.Tlong :: nil) AST.Tint
                     {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tint
     {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|})) ::
 (_main, Gfun(Internal f_main)) :: nil).

Definition public_idents : list ident :=
(_main :: _printf :: 
 nil).

Definition prog : Csyntax.program := 
  mkprogram composites global_definitions public_idents _main Logic.I.


(* above are generated by `clightgen -Csyntax`. Developments start here. *)
From stdpp Require Import base list.
From compcert Require Import Clight SimplExpr Ctypes.
Local Open Scope Z_scope.

(* step 1: apply the SimplExpr pass but not the SimplLocal pass, so everything is
still on heap *)
Definition prog_clight' :=
  transl_program prog.
  
Definition f_main_clight :=
  {|
    fn_return := tint;
    fn_callconv := cc_default;
    fn_params := nil;
    fn_vars := (_i, tint) :: (_j, tint) :: (_k, tint) :: nil;
    fn_temps := nil;
    fn_body :=
      Ssequence
        (Ssequence
           (Ssequence Sskip
              (Sassign (Evar _i tint)
                 (Econst_int (Int.repr 0) tint)))
           (Ssequence
              (Ssequence Sskip
                 (Sassign (Evar _j tint)
                    (Econst_int (Int.repr 0) tint)))
              (Ssequence
                 (Ssequence Sskip
                    (Sassign (Evar _k tint)
                       (Econst_int (Int.repr 0) tint)))
                 (Ssequence
                    (Ssequence
                       (Ssequence Sskip
                          (Sassign (Evar _i tint)
                             (Ebinop Oadd 
                                (Evar _i tint)
                                (Econst_int Int.one type_int32s)
                                (Tint I32 Signed noattr))))
                       (Ssequence
                          (Ssequence Sskip
                             (Sassign (Evar _j tint)
                                (Econst_int (Int.repr 1) tint)))
                          (Ssequence Sskip
                             (Sassign (Evar _k tint)
                                (Econst_int (Int.repr 1) tint)))))
                    (Ssequence Sskip
                       (Scall None
                          (Evar _printf
                             (Tfunction 
                                (Tcons (tptr tschar) Tnil) tint
                                {|
                                  cc_vararg := Some 1;
                                  cc_unproto := false;
                                  cc_structret := false
                                |}))
                          (Evar ___stringlit_1 (tarray tschar 24)
                           :: Evar _i tint
                              :: Evar _j tint
                                 :: Evar _k tint :: nil)))))))
        (Ssequence Sskip
           (Sreturn (Some (Econst_int (Int.repr 0) tint))))
  |}.

Definition prog_clight :=
  {|
  prog_defs :=
	(_printf,
     Gfun
       (External
          (EF_external "printf"
             {|
               sig_args := AST.Tlong :: nil;
               sig_res := AST.Tint;
               sig_cc :=
                 {|
                   cc_vararg := Some 1;
                   cc_unproto := false;
                   cc_structret := false
                 |}
             |}) (Tcons (tptr tschar) Tnil) tint
          {|
            cc_vararg := Some 1; cc_unproto := false; cc_structret := false
          |}))
    :: (_main, Gfun (Internal f_main_clight))
              :: nil;
  prog_public := public_idents;
  prog_main := _main;
  prog_types := composites;
  prog_comp_env := Maps.PTree.empty composite;
  prog_comp_env_eq := eq_refl
|}.

Lemma f_main_clight_eq :
  Errors.OK prog_clight = prog_clight'.
Proof. reflexivity. Qed.
Definition parallel_body : statement :=
  (Ssequence
    (Ssequence Sskip
      (Sassign (Evar _i tint)
          (Ebinop Oadd 
            (Evar _i tint)
            (Econst_int Int.one type_int32s)
            (Tint I32 Signed noattr))))
    (Ssequence
      (Ssequence Sskip
          (Sassign (Evar _j tint)
            (Econst_int (Int.repr 1) tint)))
      (Ssequence Sskip
          (Sassign (Evar _k tint)
            (Econst_int (Int.repr 1) tint))))).

(* step 2 : manually annotate f_main_clight with pragma steps *)
Definition f_main_omp :=
  {|
  fn_return := tint;
  fn_callconv := cc_default;
  fn_params := nil;
  fn_vars := ((_i, tint) :: (_j, tint) :: (_k, tint) :: (_l, tint) :: nil);
  fn_temps := nil;
  fn_body :=
(Ssequence
  (Ssequence
    (Sset _i (Econst_int (Int.repr 0) tint))
    (Ssequence
      (Sset _j (Econst_int (Int.repr 0) tint))
      (Ssequence
        (Sset _k (Econst_int (Int.repr 0) tint))
        (Ssequence
          (Ssequence
            (Sset _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))
            (Ssequence
              (Sset _j (Econst_int (Int.repr 1) tint))
              (Ssequence
                (Sset _k (Econst_int (Int.repr 1) tint))
                (Sset _l (Econst_int (Int.repr 0) tint)))))
          (Ssequence (Spragma 0 (OMPParallel 2 (PrivClause (_j::nil)) ((RedClause RedIdPlus (_k::nil))::nil))
                  parallel_body)
          (Scall None
            (Evar _printf (Tfunction (Tcons (tptr tschar) Tnil) tint
                            {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|}))
            ((Evar ___stringlit_1 (tarray tschar 24)) ::
             (Etempvar _i tint) :: (Etempvar _j tint) ::
             (Etempvar _k tint) :: nil)))))))
  (Sreturn (Some (Econst_int (Int.repr 0) tint))))
|}.

  Fixpoint extracting_spragma (s: statement): option statement:=
  match s with
  | Ssequence a b => match extracting_spragma a with
                    | Some s => Some s
                    | None => extracting_spragma b
                    end
  | Sifthenelse a b c => match extracting_spragma b with
                    | Some s => Some s
                    | None => extracting_spragma c
                    end   
  | Sloop a b => match extracting_spragma a with
                    | Some s => Some s
                    | None => extracting_spragma b
                    end   
  | Slabel a b => extracting_spragma b
  | Spragma a b c => Some s   
  |_ => None            
  end.
  Definition extracted_pragma_parallel_material (f: function): option function:=
  (*TODO: revise argments to mkfunction*)
  match extracting_spragma (fn_body f) with 
  | Some s => Some (mkfunction (tptr tvoid) (fn_callconv f) (fn_params f) (fn_vars f) (fn_temps f) s)
  | None => None
  end.
  Definition adding_ident (identifier: (ident * type)) (existing_list: list (ident * type)):=
  identifier::existing_list.
(*design of function: maybe recurse until encountering SPragma with parallel?*)
(* step 3: find all variables used in a parallel pragma, figure out which ones are private,
   which ones are shared and whihch ones are reduction variables.
   Nested parallel regions need recursive calls *)

   
(* shared vars, vars in the private cluse and vars in the reduction clause *)
Record pragma_info : Type := mk_pragma_info {
  shared_vars : list (ident * type);
  private_vars : list (ident * type);
  reduction_vars : list (ident * type);
  local_vars: list (ident * type )
}.

Definition empty_pragma_info : pragma_info :=
  mk_pragma_info [] [] [] [].

(* private variables are those specified in the private clause plus those in the reduction  *)
Definition parallel_info_spec (par_info: pragma_info) vars: Prop :=
  match par_info with
  | mk_pragma_info ss ps rs _ => 
      ss ⊆ vars ∧ ps ⊆ vars ∧ rs ⊆ vars ∧
      list_disjoint ss ps ∧ list_disjoint ss rs ∧ list_disjoint ps rs
  end.
 
(* lifts analysis info to an AST tagged with info *)
Inductive statementT : Type :=
  | SskipT : statementT                   (**r do nothing *)
  | SassignT : expr -> expr -> statementT (**r assignment [lvalue = rvalue] *)
  | SsetT : ident -> expr -> statementT   (**r assignment [tempvar = rvalue] *)
  | ScallT: option ident -> expr -> list expr -> statementT (**r function call *)
  | SbuiltinT: option ident -> external_function -> typelist -> list expr -> statementT (**r builtin invocation *)
  | SsequenceT : statementT -> statementT -> statementT  (**r sequence *)
  | SifthenelseT : expr  -> statementT -> statementT -> statementT (**r conditional *)
  | SloopT: statementT -> statementT -> statementT (**r infinite loop *)
  | SbreakT : statementT                      (**r [break] statementT *)
  | ScontinueT : statementT                   (**r [continue] statementT *)
  | SreturnT : option expr -> statementT      (**r [return] statementT *)
  | SswitchT : expr -> labeled_statementsT -> statementT  (**r [switch] statementT *)
  | SlabelT : label -> statementT -> statementT
  | SgotoT : label -> statementT
  (* each Spragma in the program is indexed by a uniquely natural number *)
  | SpragmaT : pragma_info -> nat -> pragma_label -> statementT -> statementT

with labeled_statementsT : Type :=            (**r cases of a [switch] *)
  | LSnilT: labeled_statementsT
  | LSconsT: option Z -> statementT -> labeled_statementsT -> labeled_statementsT.
                      (**r [None] is [default], [Some x] is [case x] *)
              
Fixpoint erase_info (sT: statementT) : statement :=
  match sT with
  | SskipT => Sskip
  | SassignT l r => Sassign l r
  | SsetT id e => Sset id e
  | ScallT id e args => Scall id e args
  | SbuiltinT id ef tl args => Sbuiltin id ef tl args
  | SsequenceT s1 s2 => Ssequence (erase_info s1) (erase_info s2)
  | SifthenelseT e s1 s2 => Sifthenelse e (erase_info s1) (erase_info s2)
  | SloopT s1 s2 => Sloop (erase_info s1) (erase_info s2)
  | SbreakT => Sbreak
  | ScontinueT => Scontinue
  | SreturnT oe => Sreturn oe
  | SswitchT e ls => Sswitch e (erase_info_labeled_statements ls)
  | SlabelT l s => Slabel l (erase_info s)
  | SgotoT l => Sgoto l
  | SpragmaT _ n pl s => Spragma n pl (erase_info s)
  end
  with erase_info_labeled_statements (lsT: labeled_statementsT) : labeled_statements :=
  match lsT with
  | LSnilT => LSnil
  | LSconsT c s ls => LScons c (erase_info s) (erase_info_labeled_statements ls)
  end
  .

(* idea: instead of dealing with nested parallel regions, we only transform the deepestly
   nested parallel region (i.e. a parallel region that does not have a parallel region nested
   inside it). Then an ident in `Evar id _` in that region must be one of these:
   1. privatized variable, must be shared in the outer parallel region. 
   2. reduction variable, similar to 1
   3. local, declared in this parallel region
   4. otherwise, shared.  *)
Fixpoint stmt_to_stmtT (stmt: statement) : statementT :=
  match stmt with
  | Sskip => SskipT
  | Sassign l r => SassignT l r
  | Sset id e => SsetT id e
  | Scall id e args => ScallT id e args
  | Sbuiltin id ef tl args => SbuiltinT id ef tl args
  | Ssequence s1 s2 => SsequenceT (stmt_to_stmtT s1) (stmt_to_stmtT s2)
  | Sifthenelse e s1 s2 => SifthenelseT e (stmt_to_stmtT s1) (stmt_to_stmtT s2)
  | Sloop s1 s2 => SloopT (stmt_to_stmtT s1) (stmt_to_stmtT s2)
  | Sbreak => SbreakT
  | Scontinue => ScontinueT
  | Sreturn oe => SreturnT oe
  | Sswitch e ls => SswitchT e (labeled_statements_to_labeled_statementsT ls)
  | Slabel l s => SlabelT l (stmt_to_stmtT s)
  | Sgoto l => SgotoT l
  | Spragma n pl stmt' => SpragmaT empty_pragma_info n pl (stmt_to_stmtT stmt')
  end
with labeled_statements_to_labeled_statementsT (ls: labeled_statements) : labeled_statementsT :=
  match ls with
  | LSnil => LSnilT
  | LScons c s ls' => LSconsT c (stmt_to_stmtT s) (labeled_statements_to_labeled_statementsT ls')
  end.

  Record annotatedFunction  : Type := makeAnnotatedFunction {
  fn_return_annot: type;
  fn_callconv_annot: calling_convention;
  fn_params_annot: list (ident * type);
  fn_vars_annot: list (ident * type);
  fn_temps_annot: list (ident * type);
  fn_body_annot: statementT
}.
(*need to convert parallel_body_T into a Clight function*)
Definition parallel_body_T : statementT :=
  (SsequenceT
    (SsequenceT SskipT
      (SassignT (Evar _i tint)
          (Ebinop Oadd 
            (Evar _i tint)
            (Econst_int Int.one type_int32s)
            (Tint I32 Signed noattr))))
    (SsequenceT
      (SsequenceT SskipT
          (SassignT (Evar _j tint)
            (Econst_int (Int.repr 1) tint)))
      (SsequenceT SskipT
          (SassignT (Evar _k tint)
            (Econst_int (Int.repr 1) tint))))).

Definition full_pragma_info : pragma_info := mk_pragma_info [(_i, tint)] [(_j, tint)] [(_k, tint)] [(_l, tint)].
Definition f_main_omp_annot :=
  {|
    fn_return_annot := tint;
  fn_callconv_annot := cc_default;
  fn_params_annot := nil;
  fn_vars_annot := ((_i, tint) :: (_j, tint) :: (_k, tint) :: (_l, tint) :: nil);
  fn_temps_annot := nil;
  fn_body_annot :=
(SsequenceT
  (SsequenceT
    (SassignT (Evar _i tint) (Econst_int (Int.repr 0) tint)) (*TODO: write pass to replace Sset with Sassign and also to move fn_temps to fn_vars*)
    (SsequenceT
      (SassignT (Evar _j tint) (Econst_int (Int.repr 0) tint))
      (SsequenceT
        (SassignT (Evar _k tint) (Econst_int (Int.repr 0) tint))
        (SsequenceT
          (SsequenceT
            (SassignT (Evar _i tint)
              (Ebinop Oadd (Evar _i tint) (Econst_int (Int.repr 1) tint)
                tint)) (* add this section (SsequenceT) to parallel_body_T*)
            (SsequenceT
              (SsetT _j (Econst_int (Int.repr 1) tint))
              (SsequenceT
                (SassignT (Evar _j tint) (Econst_int (Int.repr 1) tint))
                (SassignT (Evar _l tint)  (Econst_int (Int.repr 0) tint)))))
          (SsequenceT (SpragmaT full_pragma_info 0 (OMPParallel 2 (PrivClause (_j::nil)) ((RedClause RedIdPlus (_k::nil))::nil))
                  parallel_body_T)     
          (ScallT None
            (Evar _printf (Tfunction (Tcons (tptr tschar) Tnil) tint
                            {|cc_vararg:=(Some 1); cc_unproto:=false; cc_structret:=false|}))
            ((Evar ___stringlit_1 (tarray tschar 24)) ::
             (Evar _i tint) :: (Evar _j tint) ::
             (Evar _k tint) :: nil)))))))
  (SreturnT (Some (Econst_int (Int.repr 0) tint))))
  |}.

Fixpoint extracting_spragma_T (s: statementT): option statementT:=
  match s with
  | SsequenceT a b => match extracting_spragma_T a with
                    | Some s => Some s
                    | None => extracting_spragma_T b
                    end
  | SifthenelseT a b c => match extracting_spragma_T b with
                    | Some s => Some s
                    | None => extracting_spragma_T c
                    end   
  | SloopT a b => match extracting_spragma_T a with
                    | Some s => Some s
                    | None => extracting_spragma_T b
                    end   
  | SlabelT a b => extracting_spragma_T b
  | SpragmaT a b c d => Some s   
  |_ => None            
  end.

Definition extracted_pragma_parallel_material_T (f: annotatedFunction): option annotatedFunction:=
  (*TODO: revise argments to mkfunction*)
  match extracting_spragma_T (fn_body_annot f) with 
  | Some s => Some (makeAnnotatedFunction (tptr tvoid) (fn_callconv_annot f) (fn_params_annot f) (fn_vars_annot f) (fn_temps_annot f) s)
  | None => None
  end.

  (* Compute extracted_pragma_parallel_material_T f_main_omp_annot. *)

(*TODO: add all cases and translate SpragmaT into something that's not a pragma*)
Fixpoint compiler_to_clight_function (s: statementT) : statement :=
 match s with
  | SsequenceT a b => Ssequence (compiler_to_clight_function a) (compiler_to_clight_function b)
  | SifthenelseT a b c => Sifthenelse a (compiler_to_clight_function b) (compiler_to_clight_function c)
  | SloopT a b => Sloop (compiler_to_clight_function a) (compiler_to_clight_function b)  
  | SlabelT a b => Slabel a (compiler_to_clight_function b)
  | SpragmaT a b c d => (compiler_to_clight_function d)
  |_ => Sskip 
  (* | SpragmaT a b c d => match c with 
          | OMPParallel => 
          | OMPParallelEnd =>
          | OMPFor =>
          | OMPForEnd =>
          | OMPBarrier =>
  |_ => Sskip             *)
  end.

Definition __opaque_pthread_t : ident := $"_opaque_pthread_t".
Definition __opaque_pthread_attr_t : ident := $"_opaque_pthread_attr_t".
(*assume existence of function to create new identifiers*)

Section SpawnPass.
  Definition pos_max (l : list positive) :=
   foldr Pos.max 1%positive l.

  (*find largest int and increment by one, use list_max*)
  Definition gen_ident (idents: list ident) : (ident * list ident) :=
    let i' := ((pos_max idents) + 1)%positive in
    (i', i'::idents).
(*consider using python to make gen_ident output more readable*)
  Fixpoint spawn_thread (n: nat) (idents: list ident) (rou_id rou_arg_type_id: ident):
    (statementT *
      list ident * (* all identifiers in the program, including the type name for par routine argument *)
      list ident (*list of thread ids*)
    ) :=
  match n with 
  | O => (SskipT, [], []) 
  | S k =>
    let '(tl_stmt, idents, thread_ids) := spawn_thread k idents rou_id rou_arg_type_id in
    let (rou_arg_id, idents) := gen_ident idents in
    let (spawn_ret_id, idents) := gen_ident idents in
    let (thread_id, idents) := gen_ident idents in
    (* let init_rou_arg_code := SskipT (* TODO *) in *)
    let spawn_thread_code :=
      SsequenceT (ScallT (Some spawn_ret_id)
              (Evar _spawn (Tfunction
                              (Tcons
                                (tptr (Tfunction
                                        (Tcons (tptr tvoid) Tnil)
                                        tint cc_default))
                                (Tcons (tptr tvoid) Tnil)) tint
                              cc_default))
              ((Evar rou_id (Tfunction
                                      (Tcons (tptr tvoid) Tnil)
                                      (tptr tvoid) cc_default)) ::
                (Ecast
                  (Eaddrof
                    (Evar rou_arg_id (Tstruct rou_arg_type_id noattr))
                    (tptr (Tstruct rou_arg_type_id noattr)))
                  (tptr tvoid)) :: nil)) (SsetT thread_id (Etempvar spawn_ret_id tint)) in
      let code := SsequenceT tl_stmt spawn_thread_code in
    (code, idents, thread_id::thread_ids)
  end.

  Fixpoint post_spawn_thread_code (thread_ids: list ident): statementT := 
  match thread_ids with 
  | [] => SskipT
  | thread_id::rest_of_ids =>
  SsequenceT
  (ScallT None
    (Evar _join_thread (Tfunction (Tcons tint Tnil)
                        tvoid cc_default))
    ((Etempvar thread_id tint) :: nil)) (post_spawn_thread_code rest_of_ids)
    end. (*remove this hardcoded variable*)

  Definition spawn_threads_pass n idents arg_ty :=
  let (ni1, idents):= (gen_ident idents) in
    let (ni2, idents):= (gen_ident idents) in
    let (par_data_name, idents):= (gen_ident idents) in
    match spawn_thread n idents ni1 ni2 with
      | (spawn_thread_code, all_idents, thread_ids) => (SsequenceT (SsequenceT (
                    SsequenceT 
                      spawn_thread_code (SsequenceT (SassignT
                (Efield
                  (Evar par_data_name (Tstruct arg_ty noattr))
                  _i (tptr tint)) (Eaddrof (Evar _i tint) (tptr tint))) (SassignT
                  (Efield
                    (Evar par_data_name (Tstruct arg_ty noattr)) (*fix these hardcodings*)
                    _k (tptr tint)) (Eaddrof (Evar _k tint) (tptr tint))))) (ScallT None
                          (Evar __par_routine1 (Tfunction
                                                 (Tcons (tptr tvoid) Tnil)
                                                 (tptr tvoid) cc_default))
                          ((Ecast
                             (Eaddrof
                               (Evar par_data_name (Tstruct arg_ty noattr))
                               (tptr (Tstruct arg_ty noattr)))
                             (tptr tvoid)) :: nil))) (post_spawn_thread_code thread_ids),
                             all_idents,
                             thread_ids)
      end.
    (* 1. call spawn_thread to generate n threads
       2. init args for the main thread (line 58 in target c code)
       3. main thread runs routine (Scall)
       4. joins spawned threads *)

  
  (* set up shared vars *)
  Fixpoint set_up_shared_vars (shared_vars: list (ident * type)) (idents: list ident) (var_ident: ident) (par_data_ty: ident) (ident_matches: list (ident * ident * type)): (statementT * list (ident * ident * type)) :=
  match shared_vars with 
   | [] => (SskipT, ident_matches)
   | item::rest_of_list =>
   let (new_ident, idents') := (gen_ident idents) in
   let recursive_call := (set_up_shared_vars rest_of_list (idents') var_ident par_data_ty ([(new_ident, (fst item), (snd item))]++ident_matches)) in
    (((SsequenceT (SsetT new_ident
      (Efield
        (Ederef
          (Etempvar var_ident (tptr (Tstruct par_data_ty noattr)))
          (Tstruct par_data_ty noattr)) (fst item) (tptr tint))) (fst recursive_call))), (snd recursive_call))
   end.

  (* Definition ident_eq' p1 p2 : bool := ..

    Search BinPos.Pos.eq_dec.
  Lemma ident_eq'_ident_eq p1 p2 :
    ident_eq' p1 p2 = true <->  (ident_eq p1 p2) *)

  (* replace `Evar _i ty` with `Ederef (Etempvar __i (tptr ty)) ty` *)
  Fixpoint mk_ref_expr i i' (e: expr)  : expr :=
    match e with
    | Evar j ty => 
      if ident_eq i j
      then Ederef (Evar i' (tptr ty)) ty
      else e
    | Etempvar j ty =>
      if ident_eq i j
      then Ederef (Etempvar i' (tptr ty)) ty
      else e
    (* simple cases *)
    | Ederef e1 ty => Ederef (mk_ref_expr i i' e1) ty
    | Eaddrof e1 ty => Eaddrof (mk_ref_expr i i' e1) ty
    | Eunop op e1 ty => Eunop op (mk_ref_expr i i' e1) ty
    | Ebinop op e1 e2 ty => Ebinop op (mk_ref_expr i i' e1) (mk_ref_expr i i' e2) ty
    | Ecast e1 ty => Ecast (mk_ref_expr i i' e1) ty
    | Efield e1 field_id ty => Efield (mk_ref_expr i i' e1) field_id ty
    |_ => e
    end.

  Definition mk_ref_exprs i i' (es: list expr) : list expr:=
    map (mk_ref_expr i i') es.

  (* `i` is name of a variable of type `ty`.
     replace usage of `i` to `i'`, where `i'` holds the address of `i`. *)
  Fixpoint mk_ref_stmt i i' ty (s: statementT) : statementT :=
    match s with
    | SassignT e1 e2 => SassignT (mk_ref_expr i i' e1) (mk_ref_expr i i' e2) 
    | SsetT j e =>
      if ident_eq i j
      then SassignT (Ederef (Etempvar i' (tptr ty)) ty) (mk_ref_expr i i' e) 
      else SsetT j (mk_ref_expr i i' e)
    (* simple cases *)
    | ScallT j e_f e_args =>
      (* it seems that we can assume i!=j because Clight uses an ident
        different from the user specified ones for return value. *)
      ScallT j (mk_ref_expr i i' e_f) (mk_ref_exprs i i' e_args)
    | SbuiltinT j ef tys e_args =>
      (* it seems that we can assume i!=j because Clight uses an ident
        different from the user specified ones for return value. *)
      SbuiltinT j ef tys (mk_ref_exprs i i' e_args)
    | SsequenceT s1 s2 => SsequenceT (mk_ref_stmt i i' ty s1) (mk_ref_stmt i i' ty s2)
    | SifthenelseT e s1 s2 =>
      SifthenelseT (mk_ref_expr i i' e) (mk_ref_stmt i i' ty s1) (mk_ref_stmt i i' ty s2)
    | SloopT s1 s2 =>
      SloopT (mk_ref_stmt i i' ty s1) (mk_ref_stmt i i' ty s2)
    | SreturnT maybe_e => 
      match maybe_e with 
      | Some e => SreturnT (Some (mk_ref_expr i i' e))
      | None => SreturnT None
      end
    | SswitchT e ls => SswitchT (mk_ref_expr i i' e) ls
    | SlabelT l s => SlabelT l (mk_ref_stmt i i' ty s)
    | SpragmaT pi n pl s => SpragmaT pi n pl (mk_ref_stmt i i' ty s)
    | _ => s
    end
  with
  mk_ref_lb_stmt i i' ty (ls: labeled_statementsT) : labeled_statementsT :=
    match ls with
    | LSnilT => LSnilT
    | LSconsT l s ls' => LSconsT l (mk_ref_stmt i i' ty s) (mk_ref_lb_stmt i i' ty ls')
    end
  .

  (* ids contain the list of varibles that will be turned into references. *)
  (* s_1 := mk_ref_stmt s ids[0];
     s_2 := mk_ref_stmt s_1 ids[1];
     ... *)
  Definition mk_refs (s: statementT) (ids: list (ident * ident * type)) :statementT :=
    foldr (fun i_i'_ty s =>
      let '(i, i', ty) := i_i'_ty in
      mk_ref_stmt i i' ty s) s ids.

  Definition ident_ty_to_member_plain (ident_ty: ident * type): member :=
  let(ident, ty) := ident_ty in Member_plain ident (tptr ty).
  
  Definition gen_par_routine_input_ty (p: pragma_info) (idents: list ident): (composite_definition * ident * list ident) :=
  let '(ty_id, idents) := gen_ident idents in
  let cd := Composite ty_id Struct 
              ((map (ident_ty_to_member_plain) (shared_vars p)) ++ 
              (map (ident_ty_to_member_plain) (reduction_vars p))) 
              noattr in
  (cd, ty_id, idents).

  Definition gen_par_routine (p: pragma_info) (idents: list ident) (s_body:statementT) (arg_ty:ident) (temp_vars:list (ident * type)) : annotatedFunction :=
    let (arg_id, idents) := gen_ident idents in
    let params := ((arg_id, (tptr tvoid)) :: nil) in
    let f_body := s_body in
    let (arg_id', idents) := gen_ident (idents) in
    (* let (sec_ident, idents) := gen_ident (idents) in we need to generate the equiv of a in tgt1.c *)
    let shared_vars_setup := (set_up_shared_vars (shared_vars p) (idents) arg_id arg_ty []) in
    let f_body_post_idents_replacement := mk_refs f_body (snd shared_vars_setup) in
    makeAnnotatedFunction
      (tptr tvoid)
      cc_default
      (params)
      (private_vars p) 
      ([(arg_id, (tptr (Tstruct arg_ty noattr)))] ++ temp_vars ++ local_vars p)
      (* TO generate f_body of parallel routine f:
        1. cast argument to correct type (Ecast) (line 22 in tgt1.c)
        2. setup shared variable: a variable `i` to be shared becomes its reference version `_i`,
            initialized at beginning of f, and all `i`'s become `*_i` (line 24 )
            (*we'll need to track the connection between i and _i; maybe a map? or a list of pairs?*)
            (*when *)
        3. declare private vars
        4. declare & init local vars // init is already done in s_body
        (*use pragma info to determine type of variable*)
        5. generate definition of par_routine_1_data_ty

        How to 
      *)
   (SsequenceT (SsequenceT (SsequenceT (SsetT arg_id'
    (Ecast (Etempvar arg_id (tptr tvoid))
      (tptr (Tstruct arg_ty noattr)))) f_body_post_idents_replacement) (fst shared_vars_setup)) SskipT).
  (* Definition parallel_region : (statementT * (list ident) * (list annotatedFunction)) :=
     let '(new_body, idents', routine_arg_ty) := spawn_thread (nt - 1) idents in
              (SsequenceT new_body post_spawn_thread_code,
                idents',
                [(gen_par_routine idents' s_body routine_arg_ty temp_vars)]). *)

  (* Definition get_statement (s: statementT) *)
  (*first_pass should recurse on s_body*)
  Fixpoint first_pass (s: statementT) (idents: list ident) temp_vars : (statementT * (list ident) * (list annotatedFunction) * (list composite_definition)) :=
  match s with
    | SsequenceT a b => 
            let '(s1, idents', pr1, cd1) := (first_pass a idents temp_vars) in 
            let '(s2, idents'', pr2, cd2) := (first_pass b idents' temp_vars) in
            ((SsequenceT s1 s2), idents'', pr1++pr2, cd1++cd2)
    | SifthenelseT a b c =>   
        (* FIXME fix statements below in SsequenceT style *)
        let '(s1, idents', pr1, cd1) := (first_pass b idents temp_vars) in 
        let '(s2, idents'', pr2, cd2) := (first_pass c idents' temp_vars) in
                ((SifthenelseT a s1 s2), idents'', pr1++pr2, cd1++cd2)
    | SloopT a b =>        
        let '(s1, idents', pr1, cd1) := (first_pass a idents temp_vars) in 
        let '(s2, idents'', pr2, cd2) := (first_pass b idents temp_vars) in
                ((SloopT s1 s2), idents'', pr1++pr2, cd1++cd2)
    | SlabelT a b => let '(s1, idents', pr1, cd1) := (first_pass b idents temp_vars) in 
                    ((SlabelT a s1), idents', pr1, cd1)
    | SpragmaT a b c s_body => match c with 
            | OMPParallel nt pc rc =>
              let '(cd, ty_id, idents) := gen_par_routine_input_ty a idents in
              let '(s_body', idents, af, cds) := first_pass s_body idents temp_vars in
              let '(new_body, idents, thread_ids) := spawn_threads_pass (nt - 1) idents ty_id in
              
              (SsequenceT new_body (post_spawn_thread_code thread_ids),
                idents,
                (gen_par_routine a idents s_body' ty_id temp_vars)::af,
                cd::cds)
            | OMPFor i j => (s, [], [], [])
            (* | OMPBarrier =>SskipT *) (*may deal with later*)
            | _ => (SskipT, [], [], [])
            end
    |_ => (s, [], [], [])
    end.

Definition first_pass_eg :=
  first_pass (fn_body_annot f_main_omp_annot) [] (fn_temps_annot f_main_omp_annot).

#[local] Transparent peq.

(* simplify Clight, but keep the sugars *)
Declare Reduction simpl_clight := cbv -[
    (* C type shorthand *)
    tvoid tschar tuchar tshort tushort tint tuint tbool
    tlong tulong tfloat tdouble tptr tarray
    (* other shorthand *)
    noattr cc_default
  ].

(* fold Clight sugars back *)
Declare Reduction fold_names := fold
  _i ___stringlit_1 _i _j _k _l _main _printf _lock_1
  _lock_2 _atom_int ___par_routine1_data_1 __par_routine1_data_ty ___par_routine1_data_2
  _t2 _makelock _spawn __par_routine1 _join_thread _freelock.

(* give generated idents names *)
Definition data_ty : ident := 5%positive.
Definition unknown_ty : ident := 3%positive.
Definition par_routine_data_type : ident := 2%positive.
Declare Reduction name_idents := fold data_ty unknown_ty par_routine_data_type.

Ltac pp_program prog :=
  let term := eval simpl_clight in prog in
  let term := eval fold_names in term in
  let term := eval name_idents in term in
  idtac "The term is:" term.

Example pp_program_eg: False.
Proof.
  pp_program first_pass_eg.
Abort.

(* Eval compute in first_pass (fn_body_annot f_main_omp_annot) [] (fn_temps_annot f_main_omp_annot). *)
  
  (* Definition test: (statementT * (option pragma_info) * (option statementT)). 
  let x := eval cbn in ((first_pass (fn_body_annot f_main_omp_annot)[])) in refine x. Defined. *)
  (* Print test. *)
(*instead of compute try simpl or cbn (call by name)*)
End SpawnPass.

    (*Need to generate: 
    -a new body (replaces Spragma)*)
    (*pragma label has these options:
    Variant pragma_label : Type :=
    | OMPParallel (num_threads: nat)
                  (privatization_clause: privatization_clause_type)
                  (reduction_clauses: list reduction_clause_type)
    | OMPParallelEnd
    | OMPFor (privatization_clause: privatization_clause_type)
            (reduction_clauses: list reduction_clause_type)
    | OMPForEnd
    | OMPBarrier
  .
  pthread_create has this signature: https://man7.org/linux/man-pages/man3/pthread_create.3.html
  Final argument (in c) is the variables used

  TODO:
  Plan for compiler passes:
  First pass cannot lose information in pragma_info and pragma_label
  First pass: maybe it maintains the parallel pragma, maybe statementT to statementT
  (just about parallel pragma; translate SParallel to c code)

  When we are sure we don't need any pragma information then we can compile to statement

  Second pass: 

  *)